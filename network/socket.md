---
description: Socket이 무엇인가요?
---

# Socket이란?

> TCP 레이어에서 동작하는 네트워크에서 두 개의 프로그램 간 양방향 통신

> **네트워크 상에서 돌아가는 두 개의 프로그램 간 양방향 통신의 하나의 엔드 포인트**이다. 소켓은 **포트 번호에 바인딩**되어 TCP 레이어에서 **데이터가 전달되야하는 애플리케이션을 식별**할 수 있게 한다.

## 엔드 포인트란?

**ip주소와 포트 번호의 조합**이다. 모든 TCP 연결은 2개의 엔드 포인트로 유일하게 식별되어질 수 있다. 따라서 클라이언트와 서버 간 여러 개의 연결이 맺어질 수 있다.

## 소켓 통신

일반적으로 **서버는 특정 포트가 바인딩된 소켓을 가지고 특정 컴퓨터 위에서 돌아간다.** 해당 서버는 클라이언트의 연결 요청을 소켓을 통해 listen하면서 그냥 기다린다.

클라이언트는 서버가 떠 있는 머신의 hostname과 서버가 listen하고 있는 port번호를 알고 있다. 따라서 클라이언트는 이 hostname, port를 통해 서버와 연결을 시도한다. 또한 서버 상대로 **자신을 식별시켜주기 위해 연결하는 동안 사용될 로컬 port에 바인딩**된다. 이 port 바인딩은 보통 시스템에 의해 이뤄진다.

위 과정들이 순조롭게 이뤄진다면 서버는 연결을 수락한다. 서버는 동일한 로컬 port에 바인딩된 새로운 소켓을 얻게 되며 클라이언트의 주소와 port로 세팅된 리모트 엔드 포인트를 가지게 된다.

**서버가 별개의 새로운 소켓이 필요한 이유**는 **연결된 클라이언트의 요청을 처리**하면서, 동시에 **기존의 소켓을 통해서는 지속적으로 연결 요청을 받아야하기 때문**이다.

클라이언트 입장에서는 만약에 연결이 수락되면 소켓은 성공적으로 생성되며 클라이언트는 서버와 통신하기 위해 소켓을 사용할 수 있게 된다.

클라이언트, 서버는 이제 소켓에 데이터를 쓰거나 읽음으로써 통신할 수 있다.



### 클라이언트 소켓 흐름

1. 소켓 생성: 연결 대상에 대한 정보가 없는 껍데기 소켓 생성
2. 연결 요청(connection): 연결하고 싶은 대상한테 연결해달라는 요청을 한다. ip주소, port번호로 연결하고 싶은 대상을 특정한다. **요청에 대한 결과인 응답이 돌아와야 connect가 끝난다.**
3. 데이터의 송수신(send, receive)
   1. 요청에 대한 결과가 들어와야 실행이 끝난다.
   2. send: 데이터를 보내는 것. 데이터를 언제, 얼마나 보낼 것인지 알 수 있다.
   3. receive: 상대방이 언제, 얼마의 데이터를 보낼 것인지 알 수 없다.
   4. 때문에 수신하는 api는 별도의 thread에서 진행한다.
4. 소켓 닫기(close): 더 이상의 데이터 송수신이 필요없어지면 닫는다.



### 서버 소켓 흐름

1. 소켓 생성: 클라이언트와 동일. 클라이언트의 **연결 요청을 받는 소켓.** **실제로 클라이언트와 connect하는 소켓X**
2. 바인딩(bind): socket과 port번호를 바인딩한다. 소켓 하나가 자신을 식별할 수 있도록 socket과 고유의 port번호를 결합하는 과정
3. connection 대기(listen): 클라이언트가 연결 요청을 할 때까지 계속 기다리고 있는다. 계속 기다리다가 **연결 요청이 오면 대기 상태를 종료하고 리턴한다.(아직 연결 X)**
4. connection 수락(accept): 요청을 받아들이면서, 새로운 소켓을 생성한다. 여기서 생성된 소켓과 클라이언트 소켓을 매핑해주면 연결 끝.
   1. 연결이 끝나면 서버 소켓은 다시 연결 요청을 처리하기 위해 listen or close를 한다.
5. 데이터의 송수신(send, receive): 클라이언트와 동일
6. 소켓 닫기(close): 클라이언트와 동일



## Web Socket

> 웹에서 두 프로그램 간 메시지를 교환하기 위한 통신 방법 중 하나

소켓과는 ip, port 통신을 한다는 공통점 but 차이가 있다.

### 차이점 및 배경

웹 브라우저는 http protocol를 사용. 즉, 요청을 보내면 응답이 오는 단방향적 구조로 통신. 때문에 TCP/IP protocol을 사용하는 소켓처럼 계속 connection이 유지되는 실시간 통신을 할 수가 없다. 이런 실시간 통신의 문제점을 해결하기 위해 나온 것이 Web Socket protocol이다.

Web Socket이 나오기 전에도 http 방식으로 구현할 수는 있지만 사용에 한계가 많아 등장하게 됨.

### http로 소켓 구현하기

1. **http polling**: 클라이언트가 서버로 **주기적인 요청을 보내 새로운 이벤트가 있는지 확인**
   1. 실시간성 보장X
2. **http long polling**: 클라이언트가 서버로 요청을 보내, **어떤 이벤트가 발생할 때까지 기다림.**
   1. 만약 이벤트가 많이 발생하고 다수의 클라이언트에게서 동시에 이벤트가 발생된다면 서버의 부담이 커진다.
3. **http streaming**: 클라이언트가 서버로 요청을 보내 커넥션을 맺은 후, 이벤트가 발생해도 서버는 커넥션을 끊지 않는다.
   1. 클라이언트에서 연결을 끊지 않고 유지하기에 서버는 계속해서 클라이언트로 메시지를 보낼 수 있음
   2. but 클라이언트는 streaming을 하면서 TCP port로 읽기와 쓰기를 동시에 할 수 없기 때문에 더 이상의 요청X
   3. streaming 중 요청을 보내고 싶다면, TCP 이외의 다른 port를 이용해야 함.



### 동작 방법

#### 1. hand shaking(악수)

최초 접속 시 http request로 WebSocket 연결을 할 것이라고 **hand shaking을 거친 후 할 수 있다.** http protocol 위에서 hand shaking을 하기 때문에, http header를 사용한다.

이때 header를 통해 WebSocket Protocol로 변경(upgrade) 요청을 보낸다.

```javascript
Connection: Upgrade
Upgrade: websocket
```

라는 내용을 헤더에 작성해줘야 WebSocket으로 통신하자는 요청을 보낼 수 있다.

이후 101(Switching Protocols)상태 코드로 Protocol 전환을 승인했다고 응답을 한다. 이후 데이터를 주고 받을 수 있게 된다.

#### 2. data transfer(데이터 전송)

메시지로 데이터를 주고 받는데, 이 메시지는 Frame이라는 한 개 이상의 데이터 조작으로 구성됨.

Frame에는 텍스트 프레임, 바이너리 데이터 프레임, 핑/퐁 프레임(커넥션 유지 확인) 등이 있다.

WebSocket의 send메소드는 **텍스트, 바이너리 데이터**만 보낼 수 있다.

#### 3. close hand shaking(악수 끝)

클라이언트, 서버 모두 커넥션을 종료하기 위한 Frame을 전송할 수 있다. 종료하고 싶은 쪽에서 Connection을 종료한다는 Frame을 보내면, 상대쪽에서 응답으로 Close Frame을 전송한다.



### 단점

1. http로 구현된 방식에 비해 **구현이 복잡**하다.
2. HTML5이후에 나왔기 때문에 HTML5 **이전 기술에는 적용이 어렵다.(socket.io, sock.js로 해결가능)**
3. **Stateless**(서버의 동작, 상태 정보 저장X. 단일 요청에 대한 하나의 응답만 존재)한 http와는 달리 **Stateful**(서버의 동작, 상태 정보를 저장. 현재 상태가 이전 상태에 영향을 받음.)하므로 **연결을 항상 유지**해야 한다.
   1. 비용뿐만 아니라 항상 연결이 정상 동작한다는 보장이 없어 비정상적으로 연결이 끊기게 되는 상황에 대한 대응책이 필요

### 참고자료

* [https://www.daleseo.com/what-is-a-socket/](https://www.daleseo.com/what-is-a-socket/)
* [https://docs.oracle.com/javase/tutorial/networking/sockets/index.html](https://docs.oracle.com/javase/tutorial/networking/sockets/index.html)
* [https://mingule.tistory.com/m/60](https://mingule.tistory.com/m/60)
